// 31_03_23 (ООП Классы)
// 
// 3 кита свойства ООП:
// 
// 1) инкапсуляция (для нее характрены методы: публичные, приватные и защищенные)
// приватный метод (private), публичный (public) - например телефон позапрошлого века ("Барышня, соедините")
// Телефон - это публичный метод, но мы обращаемся не напрямую, чтобы не начался хаос. Телефон обращается к публичному методу,
// а он уже к приватному методу. Внутри капсулы: обращаемся через публичный метод к приватному, скрывая от вмешательства извне.
// напрямую к приватному методу обратиться не можем
// Абстракция - (например в классе Автомобиль  - это транспортное средство. Или когда мы управляем автомобилем: нам не важен цвет?)
// Т.е. для достижения цели (чтобы автомобиль поехал), нужен метод поворота и движения, а не метод цвета , который мы не рассматриваем
// Еще пример: нам не важно как работает электростанция, для того чтобы пропылесосить комнату или сделать тосты 
// (т.е. неважно откуда и как берется эл-во)
// Класс это реализация того, что под капотом
// Абстракция = инкапсуляция (это как рассказывать общими словами о чем-то без конкретики)
// Пример дизайна абстрактного класса для инкапсуляции (отделяем самое главное) 
// Например класс для CRM системы: пользователи; поля класса - ID (private), имя, фамилия, логин, пароль (private), СНИЛС (private), СVС (private)
// Методы для пользователя (критичные для класса, поэтому они в private): buy (private) - купить, add balance (private) - пополнение баланса, change data (private) - изменение данных и т.д.
// всё что связано с деньгами, нужно прятать всё как можно глубже в private
// нужно всю информацию проверять через сито правды, истинности, и ...
// В этом и есть прицип инкапсуляции (внутри капсулы оперировать данными, чтобы защищать информацию)
// всегда к приватному методу делаем метод-оболочку паблик
// 
// 2) полиморфизм - возможность реализации наследований от родительского класса
// Например, абстрактный класс чайник будет содержать поля класса: материал, объем.
// Методы (функции) у класса чайник: нагрев воды, принимать воду и отдавать воду.
// Полиморфизм: делает отличие чайников друг от друга (наличие каких-то функций и возможностей, отличных от других):
// автоматика и т.п., отличаясь друг от друга очень сильно. 
// Однако они наследуют свойства класса родителя абсолютно абстрактного, без которых невозможно создать чайник1, 2, 3
// Т.е. в программировании будет один и тот же метод (вскепятить воду), но с разной реализацией (через WiFi или через нажатие кнопки)
// Ещё пример на компьютерной игре. Общий абстрактный класс: монстр, у которого есть HP, энергия. Монстры могут быть разные.
// Блог (класс "принтер" который может выводить информацию на экран информацию (одним методом)) - 
// в нем нужно выводить что-то публиковать новости (может быть заголовок, имеет общий метод "принт"), 
// комментарии (не может быть заголовка, но тоже имеет общий метод "принт").
// Берем общий метод и описываем его в каждом дочернем методе.
// Если создали родительский класс с определенным набором методов, то все эти методы должны быть реализованы в дочернем классе
// (в полиморфизме есть чистые и виртуальные функции).
// Пример класс пользователь в CRM системе: классы от абстрактного класса "пользователь" наследуют !все! методы + добавляют свои. 
// Вот эти классы: Клиент, Компания, Администратор портала
// ООП прелесть: придумав минимальные методы и назначив их всем другим классам для реализации методов от родительского класса,
// то это проще для починки, если что-то сломалось (нужно просто починить родительский класс)
// 
// 3) наследование. Класс "пользователь" наследует свои методы сущностям Пользователь1, Пользователь2, и т.д.
// Во главу ООП входит ОБЪЕКТ. Объект может наследовать свойства конструктора.
// Например: Класс чайник. Переменная Тефаль = чайник. Т.О. мы унаследовали всё от класса чайник.
// 
// При проектировании класса должны реализоваться все эти три свойства.
//
//К методам класса можно обращаться по-разному
// через "." обращаемся к публичным методам из объекта
// если нужно обратьться публичным методом к классу без объекта, то
// 
// свойство privat - икапсуляция, напрямую не можем обратиться к privat
// в public всё что лежит на всеобщее обозрение
// 
// в privat  - лежит всё, что не нужно показывать другому программисту
//
#include <iostream>
using namespace std;

class FirstClass          // класс
{
public:                   // публичные методы (по сути это функция)
	void setData(int d)   // первый метод (называется так, чтобы было понятно что он делает)
	{
		data = d;
	}
	void showData()       // второй (называется так, чтобы было понятно что он делает)
	{
		cout << "Значение поля равно" << data << "\n";
	}

private:
	int data;
};


int main()
{
	setlocale(LC_ALL, "Rus");

	FirstClass variable1, variable2;

	variable1.setData(1776); // объект класса имеет внутри себя, всё что есть в классе
	variable2.setData(1886); // объект класса имеет внутри себя, всё что есть в классе
	
	variable1.showData(); // объект класса имеет внутри себя, всё что есть в классе
	variable2.showData(); // объект класса имеет внутри себя, всё что есть в классе



	system("pause");
	return 0;
}